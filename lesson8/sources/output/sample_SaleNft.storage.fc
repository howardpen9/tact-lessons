;;
;; Type: SendParameters
;; TLB: _ bounce:bool to:address value:int257 mode:int257 body:Maybe ^cell code:Maybe ^cell data:Maybe ^cell = SendParameters
;;

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_to_value_mode_body(slice to, int value, int mode, cell body) inline {
    return (true, to, value, mode, body, null(), null());
}

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_to_value_body(slice to, int value, cell body) inline {
    return (true, to, value, 0, body, null(), null());
}

;;
;; Type: Deploy
;; Header: 0x946a98b6
;; TLB: deploy#946a98b6 queryId:uint64 = Deploy
;;

(slice, ((int))) $Deploy$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 2490013878);
    var v'queryId = sc_0~load_uint(64);
    return (sc_0, (v'queryId));
}

;;
;; Type: ProvideWalletAddress
;; Header: 0x2c76b973
;; TLB: provide_wallet_address#2c76b973 query_id:uint64 owner_address:address include_address:bool = ProvideWalletAddress
;;

builder $ProvideWalletAddress$_store(builder build_0, (int, slice, int) v) inline {
    var (v'query_id, v'owner_address, v'include_address) = v;
    build_0 = store_uint(build_0, 745978227, 32);
    build_0 = build_0.store_uint(v'query_id, 64);
    build_0 = __tact_store_address(build_0, v'owner_address);
    build_0 = build_0.store_int(v'include_address, 1);
    return build_0;
}

cell $ProvideWalletAddress$_store_cell((int, slice, int) v) inline {
    return $ProvideWalletAddress$_store(begin_cell(), v).end_cell();
}

((int, slice, int)) $ProvideWalletAddress$_constructor_query_id_owner_address_include_address(int query_id, slice owner_address, int include_address) inline {
    return (query_id, owner_address, include_address);
}

;;
;; Type: TakeWalletAddress
;; Header: 0xd1735400
;; TLB: take_wallet_address#d1735400 query_id:uint64 wallet_address:address owner_address:Maybe address = TakeWalletAddress
;;

(slice, ((int, slice, slice))) $TakeWalletAddress$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 3513996288);
    var v'query_id = sc_0~load_uint(64);
    var v'wallet_address = sc_0~__tact_load_address();
    var v'owner_address = sc_0~__tact_load_address_opt();
    return (sc_0, (v'query_id, v'wallet_address, v'owner_address));
}

;;
;; Type: NftTransfer
;; Header: 0x5fcc3d14
;; TLB: nft_transfer#5fcc3d14 query_id:uint64 new_owner:address response_destination:address custom_payload:Maybe ^cell forward_amount:coins forward_payload:remainder<slice> = NftTransfer
;;

builder $NftTransfer$_store(builder build_0, (int, slice, slice, cell, int, slice) v) inline_ref {
    var (v'query_id, v'new_owner, v'response_destination, v'custom_payload, v'forward_amount, v'forward_payload) = v;
    build_0 = store_uint(build_0, 1607220500, 32);
    build_0 = build_0.store_uint(v'query_id, 64);
    build_0 = __tact_store_address(build_0, v'new_owner);
    build_0 = __tact_store_address(build_0, v'response_destination);
    build_0 = ~ null?(v'custom_payload) ? build_0.store_int(true, 1).store_ref(v'custom_payload) : build_0.store_int(false, 1);
    build_0 = build_0.store_coins(v'forward_amount);
    build_0 = build_0.store_slice(v'forward_payload);
    return build_0;
}

cell $NftTransfer$_store_cell((int, slice, slice, cell, int, slice) v) inline {
    return $NftTransfer$_store(begin_cell(), v).end_cell();
}

((int, slice, slice, cell, int, slice)) $NftTransfer$_constructor_query_id_new_owner_response_destination_custom_payload_forward_amount_forward_payload(int query_id, slice new_owner, slice response_destination, cell custom_payload, int forward_amount, slice forward_payload) inline {
    return (query_id, new_owner, response_destination, custom_payload, forward_amount, forward_payload);
}

;;
;; Type: NftOwnershipAssigned
;; Header: 0x05138d91
;; TLB: nft_ownership_assigned#05138d91 query_id:uint64 prev_owner:address forward_payload:remainder<slice> = NftOwnershipAssigned
;;

(slice, ((int, slice, slice))) $NftOwnershipAssigned$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 85167505);
    var v'query_id = sc_0~load_uint(64);
    var v'prev_owner = sc_0~__tact_load_address();
    var v'forward_payload = sc_0;
    return (sc_0, (v'query_id, v'prev_owner, v'forward_payload));
}

;;
;; Type: Transfer
;; Header: 0x0f817ea5
;; TLB: transfer#0f817ea5 query_id:uint64 amount:coins destination:address response_destination:address custom_payload:Maybe ^cell forward_ton_amount:coins forward_payload:remainder<slice> = Transfer
;;

builder $Transfer$_store(builder build_0, (int, int, slice, slice, cell, int, slice) v) inline_ref {
    var (v'query_id, v'amount, v'destination, v'response_destination, v'custom_payload, v'forward_ton_amount, v'forward_payload) = v;
    build_0 = store_uint(build_0, 260144805, 32);
    build_0 = build_0.store_uint(v'query_id, 64);
    build_0 = build_0.store_coins(v'amount);
    build_0 = __tact_store_address(build_0, v'destination);
    build_0 = __tact_store_address(build_0, v'response_destination);
    build_0 = ~ null?(v'custom_payload) ? build_0.store_int(true, 1).store_ref(v'custom_payload) : build_0.store_int(false, 1);
    build_0 = build_0.store_coins(v'forward_ton_amount);
    build_0 = build_0.store_slice(v'forward_payload);
    return build_0;
}

cell $Transfer$_store_cell((int, int, slice, slice, cell, int, slice) v) inline {
    return $Transfer$_store(begin_cell(), v).end_cell();
}

((int, int, slice, slice, cell, int, slice)) $Transfer$_constructor_query_id_amount_destination_response_destination_custom_payload_forward_ton_amount_forward_payload(int query_id, int amount, slice destination, slice response_destination, cell custom_payload, int forward_ton_amount, slice forward_payload) inline {
    return (query_id, amount, destination, response_destination, custom_payload, forward_ton_amount, forward_payload);
}

;;
;; Type: TransferNotification
;; Header: 0x7362d09c
;; TLB: transfer_notification#7362d09c query_id:uint64 amount:coins sender:address forward_payload:remainder<slice> = TransferNotification
;;

(slice, ((int, int, slice, slice))) $TransferNotification$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 1935855772);
    var v'query_id = sc_0~load_uint(64);
    var v'amount = sc_0~load_coins();
    var v'sender = sc_0~__tact_load_address();
    var v'forward_payload = sc_0;
    return (sc_0, (v'query_id, v'amount, v'sender, v'forward_payload));
}

;;
;; Type: PriceInfo
;; TLB: _ price:int257 full_price:int257 royalty_fee:int257 royalty_destination:Maybe address service_fee:int257 service_address:address = PriceInfo
;;

tuple $PriceInfo$_to_tuple(((int, int, int, slice, int, slice)) v) inline {
    var (v'price, v'full_price, v'royalty_fee, v'royalty_destination, v'service_fee, v'service_address) = v;
    return __tact_tuple_create_6(v'price, v'full_price, v'royalty_fee, v'royalty_destination, v'service_fee, v'service_address);
}

(int, int, int, slice, int, slice) $PriceInfo$_to_external(((int, int, int, slice, int, slice)) v) inline {
    var (v'price, v'full_price, v'royalty_fee, v'royalty_destination, v'service_fee, v'service_address) = v; 
    return (v'price, v'full_price, v'royalty_fee, v'royalty_destination, v'service_fee, v'service_address);
}

((int, int, int, slice, int, slice)) $PriceInfo$_constructor_price_full_price_royalty_fee_royalty_destination_service_fee_service_address(int price, int full_price, int royalty_fee, slice royalty_destination, int service_fee, slice service_address) inline {
    return (price, full_price, royalty_fee, royalty_destination, service_fee, service_address);
}

;;
;; Type: SaleInfo
;; TLB: _ sale_ended:bool owner:address nft:address nft_received:bool jetton_master:address jetton_wallet:Maybe address price_info:PriceInfo{price:int257,full_price:int257,royalty_fee:int257,royalty_destination:Maybe address,service_fee:int257,service_address:address} = SaleInfo
;;

(int, slice, slice, int, slice, slice, tuple) $SaleInfo$_to_external(((int, slice, slice, int, slice, slice, (int, int, int, slice, int, slice))) v) inline {
    var (v'sale_ended, v'owner, v'nft, v'nft_received, v'jetton_master, v'jetton_wallet, v'price_info) = v; 
    return (v'sale_ended, v'owner, v'nft, v'nft_received, v'jetton_master, v'jetton_wallet, $PriceInfo$_to_tuple(v'price_info));
}

((int, slice, slice, int, slice, slice, (int, int, int, slice, int, slice))) $SaleInfo$_constructor_sale_ended_owner_nft_nft_received_jetton_master_jetton_wallet_price_info(int sale_ended, slice owner, slice nft, int nft_received, slice jetton_master, slice jetton_wallet, (int, int, int, slice, int, slice) price_info) inline {
    return (sale_ended, owner, nft, nft_received, jetton_master, jetton_wallet, price_info);
}

;;
;; Type: SaleNft
;;

builder $SaleNft$_store(builder build_0, (slice, slice, int, slice, slice, int, int, slice, int, int) v) inline {
    var (v'owner, v'nft, v'nft_received, v'jetton_master, v'jetton_wallet, v'numerator, v'denominator, v'royalty_destination, v'sale_ended, v'price) = v;
    build_0 = __tact_store_address(build_0, v'owner);
    build_0 = __tact_store_address(build_0, v'nft);
    build_0 = build_0.store_int(v'nft_received, 1);
    build_0 = __tact_store_address(build_0, v'jetton_master);
    var build_1 = begin_cell();
    build_1 = __tact_store_address_opt(build_1, v'jetton_wallet);
    build_1 = build_1.store_uint(v'numerator, 16);
    build_1 = build_1.store_uint(v'denominator, 16);
    build_1 = __tact_store_address_opt(build_1, v'royalty_destination);
    build_1 = build_1.store_int(v'sale_ended, 1);
    build_1 = build_1.store_coins(v'price);
    build_0 = store_ref(build_0, build_1.end_cell());
    return build_0;
}

(slice, ((slice, slice, int, slice, slice, int, int, slice, int, int))) $SaleNft$_load(slice sc_0) inline {
    var v'owner = sc_0~__tact_load_address();
    var v'nft = sc_0~__tact_load_address();
    var v'nft_received = sc_0~load_int(1);
    var v'jetton_master = sc_0~__tact_load_address();
    slice sc_1 = sc_0~load_ref().begin_parse();
    var v'jetton_wallet = sc_1~__tact_load_address_opt();
    var v'numerator = sc_1~load_uint(16);
    var v'denominator = sc_1~load_uint(16);
    var v'royalty_destination = sc_1~__tact_load_address_opt();
    var v'sale_ended = sc_1~load_int(1);
    var v'price = sc_1~load_coins();
    return (sc_0, (v'owner, v'nft, v'nft_received, v'jetton_master, v'jetton_wallet, v'numerator, v'denominator, v'royalty_destination, v'sale_ended, v'price));
}

(slice, ((slice, slice, int, slice, int, int, slice))) $SaleNft$init$_load(slice sc_0) inline_ref {
    var v'owner = sc_0~__tact_load_address();
    var v'nft = sc_0~__tact_load_address();
    var v'price = sc_0~load_int(257);
    slice sc_1 = sc_0~load_ref().begin_parse();
    var v'jetton_master = sc_1~__tact_load_address();
    var v'numerator = sc_1~load_int(257);
    var v'denominator = sc_1~load_int(257);
    slice sc_2 = sc_1~load_ref().begin_parse();
    var v'royalty_destination = sc_2~__tact_load_address_opt();
    return (sc_0, (v'owner, v'nft, v'price, v'jetton_master, v'numerator, v'denominator, v'royalty_destination));
}

(slice, slice, int, slice, slice, int, int, slice, int, int) $SaleNft$_contract_load() impure inline_ref {
    slice $sc = get_data().begin_parse();
    __tact_context_sys = $sc~load_ref();
    int $loaded = $sc~load_int(1);
    if ($loaded) {
        return $sc~$SaleNft$_load();
    } else {
        ;; Allow only workchain deployments
        throw_unless(137, my_address().preload_uint(11) == 1024);
        (slice owner, slice nft, int price, slice jetton_master, int numerator, int denominator, slice royalty_destination) = $sc~$SaleNft$init$_load();
        $sc.end_parse();
        return $SaleNft$_contract_init(owner, nft, price, jetton_master, numerator, denominator, royalty_destination);
    }
}

() $SaleNft$_contract_store((slice, slice, int, slice, slice, int, int, slice, int, int) v) impure inline {
    builder b = begin_cell();
    b = b.store_ref(__tact_context_sys);
    b = b.store_int(true, 1);
    b = $SaleNft$_store(b, v);
    set_data(b.end_cell());
}